#define _CRT_SECURE_NO_WARNINGS 1
#if 0
STL六大组件：
容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器
容器：各种数据结构，如vector、list、deque、set、map等, 用来存放数据，从实现角度来看，STL容器是一种class template。
算法：各种常用的算法，如sort、find、copy、for_each。从实现的角度来看，STL算法是一种function tempalte.
迭代器：扮演了容器与算法之间的胶合剂，共有五种类型，从实现角度来看，迭代器是一种将operator*, operator->, operator++, operator--等指针相关操作予以重载的class template.所有STL容器都附带有自己专属的迭代器，只有容器的设计者才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。
仿函数：行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了operator()的class 或者class template
适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。
空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte.

STL六大组件的交互关系：
容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，适配器可以修饰仿函数。

STL优点：
内建在C++编译器中，不需要安装额外内容
不需要了解具体实现内容，只要熟练运用即可
高复用，可移植，高性能

容器(container)划分：
容器是可以嵌套的。序列式容器的元素位置是由进入容器的时机和地点来决定的。而关联式容器已经有规则了。不由进入容器的时机和地点来决定的
序列式容器，序列式容器强调值的排序，序列式容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。Vector容器、Deque容器、List容器等。
关联式容器，关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器另一个显著特点是：在值中选择一个值作为关键字key，这个关键字对值起到索引的作用，方便查找。Set / multiset容器 Map / multimap容器

算法(algorithm)：
质变算法，是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等
非质变算法，是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等

迭代器(iterator)种类：
迭代器本质上是一个类，重载了指针操作符 *和->
输入迭代器	提供对数据的只读访问	只读，支持++、 == 、！ =
输出迭代器	提供对数据的只写访问	只写，支持++
前向迭代器	提供读写操作，并能向前推进迭代器	读写，支持++、 == 、！ =
双向迭代器	提供读写操作，并能向前和向后操作	读写，支持++、--，
随机访问迭代器	提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器	读写，支持++、--、[n]、 - n、<、 <= 、>、 >=
#endif

#include <iostream>
using namespace std;

//算法：负责统计某元素的个数
int mycount(int* start, int* end, int val)
{
	int count = 0;
	while (start != end)
	{
		if (*start == val)
			count++;
		start++;
	}
	return count;
}

int main()
{
	//数组容器
	int arr[] = { 0,7,5,4,9,2,0 };

	//迭代器
	int* pBegin = arr;//指向容器的第一个元素位置
	int* pEnd = &(arr[sizeof(arr) / sizeof(int)]);//指向容器的最后一个元素的下一个位置
	
	int num = mycount(pBegin, pEnd, 0);
	cout << "0的个数num = ：" << num << endl;

	return 0;
}