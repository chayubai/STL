#define _CRT_SECURE_NO_WARNINGS 1
#if 0
				vector		deque		list		set		multiset	map			multimap
典型内存结构	单端数组	双端数组	双向链表	二叉树	二叉树		二叉树		二叉树
可随机存取		是			是			否			否		否	   对key而言：是	否
元素搜寻速度	慢			慢			非常慢		快		快	   对key而言：快	对key而言：快
元素安插移除	尾端		头尾两端	任何位置	-		-			-			-
vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。
deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。
如果采用vector，则头端移除时，会移动大量的数据，速度慢。
vector与deque的比较：
	一：vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置	却是不固定的。
	二：如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。
	三：deque支持头部的快速插入与快速移除，这是deque的优点。
list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。
set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。
map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。
如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。

#endif

//不支持随机访问，这是由结构所决定的
//如：对于list容器，底层的数据结构是(双向)链表，因此不支持随机访问
//同理：对于
//string底层是动态开辟的数组(顺序表)，支持随机访问
//vector底层是动态开辟的数组(顺序表)，支持随机访问
//duque底层是动态开辟的数组(顺序表)，支持随机访问
//stack底层可以是顺序表或者链表，但是STL应该是链表，不支持随机访问
//queue底层可以是顺序表或者链表，但是STL应该是链表，不支持随机访问
//list底层是双向链表，不支持随机访问
//set/multiset或者map/multimap底层是二叉树(链表的一种)，不支持随机访问

//对于string/vector/duque都能使用"[]"访问元素
//对于stack/queue/list/set/multiset/map/multimap 不支持随机访问，即都不能使用"[]"访问元素
//注意：map/multimap可以根据key值，使用"[]"赋值和输出value值